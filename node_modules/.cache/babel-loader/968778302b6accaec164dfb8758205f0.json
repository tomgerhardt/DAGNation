{"ast":null,"code":"import { useMemo } from 'react';\nimport { useRawCalls } from './useRawCalls';\nimport { decodeCallResult, encodeCallData } from '../helpers';\nimport { useChainId } from './useChainId';\n/**\n * Makes a call to a specific method of a specific contract and returns the value or an error if present.\n * The hook will cause the component to refresh when a new block is mined and the return value changes.\n * A syntax sugar for useRawCall that uses ABI, function name, and arguments instead of raw data.\n * If typechain contract is used in call parameter then method name and arguments will be type checked.\n * Result will be typed as well.\n *\n * @param call a single call to a contract , also see {@link Call}\n * @returns The hook returns {@link CallResult} type.\n *          That is: undefined when call didn't return yet or a object { value | error } if it did,\n *          value: any[] | undefined - array of results or undefined if error occurred,\n *          error: Error | undefined - encountered error or undefined if call was successful.\n */\n\nexport function useCall(call) {\n  var queryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return useCalls([call], queryParams)[0];\n}\n/**\n * Makes calls to specific methods of specific contracts and returns values or an error if present.\n * The hook will cause the component to refresh when a new block is mined and the return values change.\n * A syntax sugar for useRawCalls that uses ABI, function name, and arguments instead of raw data.\n * @param calls a list of contract calls , also see {@link Call}.\n * @param queryParams see {@link QueryParams}.\n * @returns a list of results (see {@link CallResult} in {@link useCall} above).\n */\n\nexport function useCalls(calls) {\n  var queryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var chainId = useChainId({\n    queryParams: queryParams\n  });\n  var rawCalls = useMemo(function () {\n    return calls.map(function (call) {\n      return chainId !== undefined ? encodeCallData(call, chainId) : undefined;\n    });\n  }, [JSON.stringify(calls.map(function (call) {\n    return call && {\n      address: call.contract.address.toLowerCase(),\n      method: call.method,\n      args: call.args\n    };\n  })), chainId]);\n  var results = useRawCalls(rawCalls);\n  return useMemo(function () {\n    return results.map(function (result, idx) {\n      return decodeCallResult(calls[idx], result);\n    });\n  }, [results]);\n}","map":{"version":3,"mappings":"AAAA,SAASA,OAAT,QAAwB,OAAxB;AAGA,SAASC,WAAT,QAA4B,eAA5B;AACA,SAAqBC,gBAArB,EAAuCC,cAAvC,QAA6D,YAA7D;AAEA,SAASC,UAAT,QAA2B,cAA3B;AAWA;;;;;;;;;;;;;;AAaA,OAAM,SAAUC,OAAV,CACJC,IADI,EAEyB;AAAA,MAA7BC,WAA6B,uEAAF,EAAE;AAE7B,SAAOC,QAAQ,CAAC,CAACF,IAAD,CAAD,EAASC,WAAT,CAAR,CAA8B,CAA9B,CAAP;AACD;AAED;;;;;;;;;AAQA,OAAM,SAAUC,QAAV,CAAmBC,KAAnB,EAAyE;AAAA,MAA7BF,WAA6B,uEAAF,EAAE;AAC7E,MAAMG,OAAO,GAAGN,UAAU,CAAC;AAAEG,eAAW,EAAXA;AAAF,GAAD,CAA1B;AAEA,MAAMI,QAAQ,GAAGX,OAAO,CACtB;AAAA,WAAMS,KAAK,CAACG,GAAN,CAAU,UAACN,IAAD;AAAA,aAAWI,OAAO,KAAKG,SAAZ,GAAwBV,cAAc,CAACG,IAAD,EAAOI,OAAP,CAAtC,GAAwDG,SAAnE;AAAA,KAAV,CAAN;AAAA,GADsB,EAEtB,CACEC,IAAI,CAACC,SAAL,CACEN,KAAK,CAACG,GAAN,CACE,UAACN,IAAD;AAAA,WAAUA,IAAI,IAAI;AAAEU,aAAO,EAAEV,IAAI,CAACW,QAAL,CAAcD,OAAd,CAAsBE,WAAtB,EAAX;AAAgDC,YAAM,EAAEb,IAAI,CAACa,MAA7D;AAAqEC,UAAI,EAAEd,IAAI,CAACc;AAAhF,KAAlB;AAAA,GADF,CADF,CADF,EAMEV,OANF,CAFsB,CAAxB;AAWA,MAAMW,OAAO,GAAGpB,WAAW,CAACU,QAAD,CAA3B;AACA,SAAOX,OAAO,CAAC;AAAA,WAAMqB,OAAO,CAACT,GAAR,CAAY,UAACU,MAAD,EAASC,GAAT;AAAA,aAAiBrB,gBAAgB,CAACO,KAAK,CAACc,GAAD,CAAN,EAAaD,MAAb,CAAjC;AAAA,KAAZ,CAAN;AAAA,GAAD,EAA2E,CAACD,OAAD,CAA3E,CAAd;AACD","names":["useMemo","useRawCalls","decodeCallResult","encodeCallData","useChainId","useCall","call","queryParams","useCalls","calls","chainId","rawCalls","map","undefined","JSON","stringify","address","contract","toLowerCase","method","args","results","result","idx"],"sources":["../../../../src/hooks/useCall.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}