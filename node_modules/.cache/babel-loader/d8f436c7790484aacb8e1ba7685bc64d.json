{"ast":null,"code":"import { useCallback, useState } from 'react';\nimport { useEthers } from './useEthers';\nimport { usePromiseTransaction } from './usePromiseTransaction';\n/**\n * @internal Intended for internal use - use it on your own risk\n */\n\nexport function connectContractToSigner(contract, options, library) {\n  if (contract.signer) {\n    return contract;\n  }\n\n  if (options === null || options === void 0 ? void 0 : options.signer) {\n    return contract.connect(options.signer);\n  }\n\n  if (library === null || library === void 0 ? void 0 : library.getSigner()) {\n    return contract.connect(library.getSigner());\n  }\n\n  throw new TypeError('No signer available in contract, options or library');\n}\n/**\n * @public\n */\n\nexport function useContractFunction(contract, functionName, options) {\n  const {\n    library,\n    chainId\n  } = useEthers();\n  const {\n    promiseTransaction,\n    state,\n    resetState\n  } = usePromiseTransaction(chainId, options);\n  const [events, setEvents] = useState(undefined);\n  const send = useCallback(async function () {\n    const contractWithSigner = connectContractToSigner(contract, options, library);\n    const receipt = await promiseTransaction(contractWithSigner[functionName](...arguments));\n\n    if (receipt === null || receipt === void 0 ? void 0 : receipt.logs) {\n      const events = receipt.logs.reduce((accumulatedLogs, log) => {\n        try {\n          return log.address.toLowerCase() === contract.address.toLowerCase() ? [...accumulatedLogs, contract.interface.parseLog(log)] : accumulatedLogs;\n        } catch (_err) {\n          return accumulatedLogs;\n        }\n      }, []);\n      setEvents(events);\n    }\n  }, [contract, functionName, options, library]);\n  return {\n    send,\n    state,\n    events,\n    resetState\n  };\n}","map":{"version":3,"mappings":"AAGA,SAASA,WAAT,EAAsBC,QAAtB,QAAsC,OAAtC;AACA,SAASC,SAAT,QAA0B,aAA1B;AACA,SAASC,qBAAT,QAAsC,yBAAtC;AAIA;;;;AAGA,OAAM,SAAUC,uBAAV,CAAkCC,QAAlC,EAAsDC,OAAtD,EAAoFC,OAApF,EAA6G;AACjH,MAAIF,QAAQ,CAACG,MAAb,EAAqB;AACnB,WAAOH,QAAP;AACD;;AAED,MAAIC,OAAO,SAAP,WAAO,WAAP,GAAO,MAAP,UAAO,CAAEE,MAAb,EAAqB;AACnB,WAAOH,QAAQ,CAACI,OAAT,CAAiBH,OAAO,CAACE,MAAzB,CAAP;AACD;;AAED,MAAID,OAAO,SAAP,WAAO,WAAP,GAAO,MAAP,UAAO,CAAEG,SAAT,EAAJ,EAA0B;AACxB,WAAOL,QAAQ,CAACI,OAAT,CAAiBF,OAAO,CAACG,SAAR,EAAjB,CAAP;AACD;;AAED,QAAM,IAAIC,SAAJ,CAAc,qDAAd,CAAN;AACD;AAED;;;;AAGA,OAAM,SAAUC,mBAAV,CACJP,QADI,EAEJQ,YAFI,EAGJP,OAHI,EAGwB;AAE5B,QAAM;AAAEC,WAAF;AAAWO;AAAX,MAAuBZ,SAAS,EAAtC;AACA,QAAM;AAAEa,sBAAF;AAAsBC,SAAtB;AAA6BC;AAA7B,MAA4Cd,qBAAqB,CAACW,OAAD,EAAUR,OAAV,CAAvE;AACA,QAAM,CAACY,MAAD,EAASC,SAAT,IAAsBlB,QAAQ,CAA+BmB,SAA/B,CAApC;AAEA,QAAMC,IAAI,GAAGrB,WAAW,CACtB,kBAAgD;AAC9C,UAAMsB,kBAAkB,GAAGlB,uBAAuB,CAACC,QAAD,EAAWC,OAAX,EAAoBC,OAApB,CAAlD;AACA,UAAMgB,OAAO,GAAG,MAAMR,kBAAkB,CAACO,kBAAkB,CAACT,YAAD,CAAlB,CAAiC,YAAjC,CAAD,CAAxC;;AACA,QAAIU,OAAO,SAAP,WAAO,WAAP,GAAO,MAAP,UAAO,CAAEC,IAAb,EAAmB;AACjB,YAAMN,MAAM,GAAGK,OAAO,CAACC,IAAR,CAAaC,MAAb,CAAoB,CAACC,eAAD,EAAkBC,GAAlB,KAAyB;AAC1D,YAAI;AACF,iBAAOA,GAAG,CAACC,OAAJ,CAAYC,WAAZ,OAA8BxB,QAAQ,CAACuB,OAAT,CAAiBC,WAAjB,EAA9B,GACH,CAAC,GAAGH,eAAJ,EAAqBrB,QAAQ,CAACyB,SAAT,CAAmBC,QAAnB,CAA4BJ,GAA5B,CAArB,CADG,GAEHD,eAFJ;AAGD,SAJD,CAIE,OAAOM,IAAP,EAAa;AACb,iBAAON,eAAP;AACD;AACF,OARc,EAQZ,EARY,CAAf;AASAP,eAAS,CAACD,MAAD,CAAT;AACD;AACF,GAhBqB,EAiBtB,CAACb,QAAD,EAAWQ,YAAX,EAAyBP,OAAzB,EAAkCC,OAAlC,CAjBsB,CAAxB;AAoBA,SAAO;AAAEc,QAAF;AAAQL,SAAR;AAAeE,UAAf;AAAuBD;AAAvB,GAAP;AACD","names":["useCallback","useState","useEthers","usePromiseTransaction","connectContractToSigner","contract","options","library","signer","connect","getSigner","TypeError","useContractFunction","functionName","chainId","promiseTransaction","state","resetState","events","setEvents","undefined","send","contractWithSigner","receipt","logs","reduce","accumulatedLogs","log","address","toLowerCase","interface","parseLog","_err"],"sources":["../../../../src/hooks/useContractFunction.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}