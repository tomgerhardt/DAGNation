{"ast":null,"code":"import { useMemo } from 'react';\nimport { useRawCalls } from './useRawCalls';\nimport { decodeCallResult, encodeCallData } from '../helpers';\nimport { useChainId } from './useChainId';\n/**\n * Makes a call to a specific method of a specific contract and returns the value or an error if present.\n * The hook will cause the component to refresh when a new block is mined and the return value changes.\n * A syntax sugar for useRawCall that uses ABI, function name, and arguments instead of raw data.\n * If typechain contract is used in call parameter then method name and arguments will be type checked.\n * Result will be typed as well.\n *\n * @param call a single call to a contract , also see {@link Call}\n * @returns The hook returns {@link CallResult} type.\n *          That is: undefined when call didn't return yet or a object { value | error } if it did,\n *          value: any[] | undefined - array of results or undefined if error occurred,\n *          error: Error | undefined - encountered error or undefined if call was successful.\n */\n\nexport function useCall(call) {\n  let queryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return useCalls([call], queryParams)[0];\n}\n/**\n * Makes calls to specific methods of specific contracts and returns values or an error if present.\n * The hook will cause the component to refresh when a new block is mined and the return values change.\n * A syntax sugar for useRawCalls that uses ABI, function name, and arguments instead of raw data.\n * @param calls a list of contract calls , also see {@link Call}.\n * @param queryParams see {@link QueryParams}.\n * @returns a list of results (see {@link CallResult} in {@link useCall} above).\n */\n\nexport function useCalls(calls) {\n  let queryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const chainId = useChainId({\n    queryParams\n  });\n  const rawCalls = useMemo(() => calls.map(call => chainId !== undefined ? encodeCallData(call, chainId) : undefined), [JSON.stringify(calls.map(call => call && {\n    address: call.contract.address.toLowerCase(),\n    method: call.method,\n    args: call.args\n  })), chainId]);\n  const results = useRawCalls(rawCalls);\n  return useMemo(() => results.map((result, idx) => decodeCallResult(calls[idx], result)), [results]);\n}","map":{"version":3,"mappings":"AAAA,SAASA,OAAT,QAAwB,OAAxB;AAGA,SAASC,WAAT,QAA4B,eAA5B;AACA,SAAqBC,gBAArB,EAAuCC,cAAvC,QAA6D,YAA7D;AAEA,SAASC,UAAT,QAA2B,cAA3B;AAWA;;;;;;;;;;;;;;AAaA,OAAM,SAAUC,OAAV,CACJC,IADI,EAEyB;AAAA,MAA7BC,WAA6B,uEAAF,EAAE;AAE7B,SAAOC,QAAQ,CAAC,CAACF,IAAD,CAAD,EAASC,WAAT,CAAR,CAA8B,CAA9B,CAAP;AACD;AAED;;;;;;;;;AAQA,OAAM,SAAUC,QAAV,CAAmBC,KAAnB,EAAyE;AAAA,MAA7BF,WAA6B,uEAAF,EAAE;AAC7E,QAAMG,OAAO,GAAGN,UAAU,CAAC;AAAEG;AAAF,GAAD,CAA1B;AAEA,QAAMI,QAAQ,GAAGX,OAAO,CACtB,MAAMS,KAAK,CAACG,GAAN,CAAWN,IAAD,IAAWI,OAAO,KAAKG,SAAZ,GAAwBV,cAAc,CAACG,IAAD,EAAOI,OAAP,CAAtC,GAAwDG,SAA7E,CADgB,EAEtB,CACEC,IAAI,CAACC,SAAL,CACEN,KAAK,CAACG,GAAN,CACGN,IAAD,IAAUA,IAAI,IAAI;AAAEU,WAAO,EAAEV,IAAI,CAACW,QAAL,CAAcD,OAAd,CAAsBE,WAAtB,EAAX;AAAgDC,UAAM,EAAEb,IAAI,CAACa,MAA7D;AAAqEC,QAAI,EAAEd,IAAI,CAACc;AAAhF,GADpB,CADF,CADF,EAMEV,OANF,CAFsB,CAAxB;AAWA,QAAMW,OAAO,GAAGpB,WAAW,CAACU,QAAD,CAA3B;AACA,SAAOX,OAAO,CAAC,MAAMqB,OAAO,CAACT,GAAR,CAAY,CAACU,MAAD,EAASC,GAAT,KAAiBrB,gBAAgB,CAACO,KAAK,CAACc,GAAD,CAAN,EAAaD,MAAb,CAA7C,CAAP,EAA2E,CAACD,OAAD,CAA3E,CAAd;AACD","names":["useMemo","useRawCalls","decodeCallResult","encodeCallData","useChainId","useCall","call","queryParams","useCalls","calls","chainId","rawCalls","map","undefined","JSON","stringify","address","contract","toLowerCase","method","args","results","result","idx"],"sources":["../../../../src/hooks/useCall.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}